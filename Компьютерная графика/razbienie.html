<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Correct Interior Triangulation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        .controls {
            margin-bottom: 15px;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            margin: 0 5px;
        }

        button:hover { background-color: #0056b3; }
        button.reset { background-color: #dc3545; }

        canvas {
            background-color: #050510;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            cursor: crosshair;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .info {
            margin-top: 15px;
            color: #888;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>

    <h1 style="color: #00d4ff;">Внутренняя триангуляция (Ear Clipping)</h1>

    <div class="controls">
        <button onclick="calculate()">Триангулировать внутри</button>
        <button class="reset" onclick="resetCanvas()">Очистить</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info">
        Ставьте точки последовательно. Алгоритм автоматически определит внутреннюю область.
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let points = [];
        let triangles = [];
        let isFinished = false;

        canvas.addEventListener('mousedown', (e) => {
            if (isFinished) resetCanvas();
            const rect = canvas.getBoundingClientRect();
            points.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
            draw();
        });

        function resetCanvas() {
            points = [];
            triangles = [];
            isFinished = false;
            draw();
        }

        function calculate() {
            if (points.length < 3) return;

            let vertices = [...points];

            // 1. В Canvas (Y-вниз) отриц. площадь = CCW (против часовой).
            // Принудительно приводим к CCW, чтобы математика "уха" работала корректно.
            if (getSignedArea(vertices) > 0) {
                vertices.reverse();
            }

            triangles = [];
            let workList = [...vertices];

            // Ограничитель итераций на случай вырожденных фигур
            let maxIters = workList.length * 10; 
            
            while (workList.length > 3 && maxIters > 0) {
                let earFound = false;

                for (let i = 0; i < workList.length; i++) {
                    if (isEar(workList, i)) {
                        const prev = workList[(i - 1 + workList.length) % workList.length];
                        const curr = workList[i];
                        const next = workList[(i + 1) % workList.length];

                        triangles.push([prev, curr, next]);
                        workList.splice(i, 1);
                        earFound = true;
                        break;
                    }
                }
                if (!earFound) break;
                maxIters--;
            }

            if (workList.length === 3) {
                triangles.push([workList[0], workList[1], workList[2]]);
            }

            isFinished = true;
            draw();
        }

        // Проверка на "ухо" (должно быть выпуклым И пустым внутри)
        function isEar(poly, i) {
            const n = poly.length;
            const a = poly[(i - 1 + n) % n];
            const b = poly[i];
            const c = poly[(i + 1) % n];

            // В системе Y-вниз при обходе CCW, 
            // внутренний угол выпуклый, если векторное произведение < 0
            if (crossProduct(a, b, c) >= 0) return false;

            // Проверка: нет ли других точек внутри этого треугольника
            for (let j = 0; j < n; j++) {
                const p = poly[j];
                if (p === a || p === b || p === c) continue;
                if (isPointInTriangle(p, a, b, c)) return false;
            }

            return true;
        }

        function crossProduct(a, b, c) {
            // (x2-x1)*(y3-y2) - (y2-y1)*(x3-x2)
            return (b.x - a.x) * (c.y - b.y) - (b.y - a.y) * (c.x - b.x);
        }

        function isPointInTriangle(p, a, b, c) {
            // Барицентрические координаты для проверки попадания точки в треугольник
            const det = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);
            const s = ((b.y - c.y) * (p.x - c.x) + (c.x - b.x) * (p.y - c.y)) / det;
            const t = ((c.y - a.y) * (p.x - c.x) + (a.x - c.x) * (p.y - c.y)) / det;
            const u = 1 - s - t;
            return s >= 0 && t >= 0 && u >= 0;
        }

        function getSignedArea(poly) {
            let area = 0;
            for (let i = 0; i < poly.length; i++) {
                const j = (i + 1) % poly.length;
                area += (poly[i].x * poly[j].y - poly[j].x * poly[i].x); // Упрощенная формула Гаусса
            }
            // Правильная формула площади для Canvas:
            let a = 0;
            for(let i=0; i<poly.length; i++){
                let next = (i+1)%poly.length;
                a += (poly[i].x * poly[next].y) - (poly[next].x * poly[i].y);
            }
            return a / 2;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Сетка
            ctx.strokeStyle = '#222';
            for(let i=0; i<800; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke(); }
            for(let i=0; i<600; i+=40) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(800,i); ctx.stroke(); }

            // Треугольники
            triangles.forEach((tri, index) => {
                ctx.beginPath();
                ctx.moveTo(tri[0].x, tri[0].y);
                ctx.lineTo(tri[1].x, tri[1].y);
                ctx.lineTo(tri[2].x, tri[2].y);
                ctx.closePath();
                
                const hue = (index * 137) % 360; // Золотое сечение для разброса цветов
                ctx.fillStyle = `hsla(${hue}, 60%, 40%, 0.4)`;
                ctx.fill();
                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 1)`;
                ctx.stroke();
            });

            // Контур
            if (points.length > 0) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                if (isFinished) ctx.closePath();
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 2;
                ctx.stroke();

                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = "#fff";
                    ctx.fill();
                });
            }
        }
    </script>
</body>

</html>