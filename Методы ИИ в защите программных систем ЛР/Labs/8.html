<!-- task8_gamma64.html -->
<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Gamma Cipher (64-bit ADD)</title>
    <style>
        body {
            background-color: #0d0d0d;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .terminal {
            width: 800px;
            border: 2px solid #00ff00;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            background: #000;
        }

        h1 {
            text-shadow: 0 0 5px #00ff00;
            border-bottom: 1px dashed #00ff00;
            padding-bottom: 10px;
        }

        .section {
            margin-bottom: 30px;
            padding: 10px;
            border-left: 2px solid #004400;
        }

        input[type="file"] {
            margin: 10px 0;
            color: #fff;
        }

        button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
        }

        button:hover {
            background: #00ff00;
            color: #000;
        }

        button:disabled {
            border-color: #555;
            color: #555;
            background: #111;
            cursor: not-allowed;
        }

        .log {
            margin-top: 10px;
            color: #88ff88;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        a {
            color: #fff;
            text-decoration: none;
            border-bottom: 1px solid #fff;
            margin-right: 15px;
        }

        a:hover {
            background: #fff;
            color: #000;
        }

        .warn {
            color: #ff3333;
        }
    </style>
</head>

<body>

    <div class="terminal">
        <h1>>>> GAMMA_CIPHER_64BIT_ADDITION_MODE</h1>

        <div class="section">
            <h3>[ OPERATION: ENCRYPT ]</h3>
            <div>TARGET FILE: <input type="file" id="encFile"></div>
            <button id="btnEnc" onclick="processFile('encrypt')">INITIATE ENCRYPTION</button>
            <div id="encLog" class="log">WAITING FOR INPUT...</div>
            <div id="encLinks" class="log"></div>
        </div>

        <div class="section">
            <h3>[ OPERATION: DECRYPT ]</h3>
            <div>ENCRYPTED FILE (.bin): <input type="file" id="decFile"></div>
            <div>KEY FILE (.key): <input type="file" id="keyFile"></div>
            <button id="btnDec" onclick="processFile('decrypt')">INITIATE DECRYPTION</button>
            <div id="decLog" class="log">WAITING FOR INPUTS...</div>
            <div id="decLinks" class="log"></div>
        </div>
    </div>

    <script>
        // Константа модуля 2^64
        const MOD64 = 18446744073709551616n; // 2n ** 64n

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function download(blob, name, containerId) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            a.textContent = `[ DOWNLOAD ${name} ]`;
            document.getElementById(containerId).appendChild(a);
        }

        async function processFile(mode) {
            const logId = mode === 'encrypt' ? 'encLog' : 'decLog';
            const linkId = mode === 'encrypt' ? 'encLinks' : 'decLinks';
            const log = document.getElementById(logId);
            document.getElementById(linkId).innerHTML = '';

            try {
                if (mode === 'encrypt') {
                    const fileInput = document.getElementById('encFile');
                    if (!fileInput.files[0]) throw new Error("NO FILE SELECTED");

                    log.textContent = ">>> READING DATA...";
                    const rawData = await readFile(fileInput.files[0]);
                    const originalLen = rawData.byteLength;

                    // 1. Паддинг до 8 байт (64 бит)
                    const padding = (8 - (originalLen % 8)) % 8;
                    const paddedLen = originalLen + padding;

                    // Создаем буфер + 8 байт для хранения длины исходного файла
                    const buffer = new ArrayBuffer(paddedLen + 8);
                    const view = new DataView(buffer);
                    new Uint8Array(buffer).set(new Uint8Array(rawData)); // Копируем данные

                    // Записываем реальную длину в конец файла (последние 8 байт) для восстановления
                    view.setBigUint64(paddedLen, BigInt(originalLen), true); // Little Endian

                    const blockCount = paddedLen / 8; // Количество блоков данных

                    log.textContent = `>>> GENERATING 64-BIT KEYS FOR ${blockCount} BLOCKS...`;

                    // 2. Генерация гаммы (ключа)
                    const keyBuffer = new ArrayBuffer(blockCount * 8);
                    const keyView = new DataView(keyBuffer);
                    // Crypto.getRandomValues работает макс с 65536 байтами, нужно циклом если файл большой
                    // Для простоты используем упрощенную генерацию BigInt (в проде нужен CSPRNG)
                    for (let i = 0; i < blockCount; i++) {
                        // Генерируем случайное 64-битное число
                        const rnd = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)) *
                            BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
                        keyView.setBigUint64(i * 8, rnd, true);
                    }

                    log.textContent = ">>> ENCRYPTING (ADDITION MOD 2^64)...";

                    const outBuffer = new ArrayBuffer(blockCount * 8 + 8); // Данные + метаданные длины
                    const outView = new DataView(outBuffer);

                    // Копируем метаданные длины в конец шифротекста
                    outView.setBigUint64(blockCount * 8, BigInt(originalLen), true);

                    for (let i = 0; i < blockCount; i++) {
                        const P = view.getBigUint64(i * 8, true); // Читаем как Little Endian
                        const K = keyView.getBigUint64(i * 8, true);

                        // C = (P + K) mod 2^64
                        // В JS BigUint64 автоматически работает по модулю 2^64 при переполнении, 
                        // но BigInt операции требуют явного модуля для корректности
                        let C = (P + K) % MOD64;

                        outView.setBigUint64(i * 8, C, true);
                    }

                    log.textContent = ">>> DONE. PREPARING DOWNLOADS.";

                    download(new Blob([outBuffer]), fileInput.files[0].name + ".bin", linkId);
                    download(new Blob([keyBuffer]), fileInput.files[0].name + ".key", linkId);

                } else {
                    // DECRYPT
                    const encInput = document.getElementById('decFile');
                    const keyInput = document.getElementById('keyFile');
                    if (!encInput.files[0] || !keyInput.files[0]) throw new Error("MISSING FILES");

                    log.textContent = ">>> READING DATA...";
                    const encData = await readFile(encInput.files[0]);
                    const keyData = await readFile(keyInput.files[0]);

                    const encView = new DataView(encData);
                    const keyView = new DataView(keyData);

                    // Последние 8 байт шифротекста - это исходная длина
                    const totalSize = encData.byteLength;
                    const originalLen = Number(encView.getBigUint64(totalSize - 8, true));
                    const dataLen = totalSize - 8; // Размер зашифрованных блоков

                    if (keyData.byteLength !== dataLen) throw new Error("KEY FILE SIZE MISMATCH");

                    log.textContent = ">>> DECRYPTING (SUBTRACTION MOD 2^64)...";

                    const outBuffer = new ArrayBuffer(dataLen);
                    const outView = new DataView(outBuffer);
                    const blockCount = dataLen / 8;

                    for (let i = 0; i < blockCount; i++) {
                        const C = encView.getBigUint64(i * 8, true);
                        const K = keyView.getBigUint64(i * 8, true);

                        // P = (C - K) mod 2^64
                        let P = (C - K) % MOD64;
                        if (P < 0n) P += MOD64; // Обработка отрицательного результата

                        outView.setBigUint64(i * 8, P, true);
                    }

                    log.textContent = ">>> TRIMMING PADDING...";
                    // Обрезаем до оригинальной длины
                    const finalBlob = new Blob([new Uint8Array(outBuffer, 0, originalLen)]);

                    download(finalBlob, "decrypted_" + encInput.files[0].name.replace('.bin', ''), linkId);
                    log.textContent = ">>> SUCCESS.";
                }
            } catch (e) {
                log.textContent = `>>> ERROR: ${e.message}`;
                log.classList.add('warn');
                console.error(e);
            }
        }
    </script>
</body>

</html>