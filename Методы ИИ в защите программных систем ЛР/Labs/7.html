<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è —á–µ—Ä–µ–∑ DES (–ª–∞–±–∞ 5)</title>
<style>
body {
  font-family: Arial, sans-serif;
  background: linear-gradient(135deg, #667eea, #764ba2);
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  color: #333;
}
.container {
  background: #fff;
  border-radius: 20px;
  padding: 40px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  width: 400px;
}
h2 { text-align: center; margin-bottom: 20px; }
input, button {
  width: 100%; padding: 12px; margin-top: 10px;
  border-radius: 8px; border: 1px solid #ccc;
}
button {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: #fff; border: none; cursor: pointer;
}
.result {
  margin-top: 20px;
  background: #f7f7f7;
  padding: 15px;
  border-radius: 10px;
  font-family: monospace;
  word-break: break-all;
}
</style>
</head>
<body>
<div class="container">
  <h2>üîê –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è (DES –∏–∑ –ª–∞–±—ã ‚Ññ4)</h2>
  <input type="text" id="password" maxlength="12" placeholder="–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å (12 —Å–∏–º–≤–æ–ª–æ–≤)">
  <input type="text" id="keyInput" maxlength="8" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á (8 —Å–∏–º–≤–æ–ª–æ–≤)">
  <button onclick="hashPassword()">–°–æ–∑–¥–∞—Ç—å —Ö–µ—à</button>
  <div class="result" id="output"></div>
</div>

    <script>
        // DES Implementation (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å 32-–±–∏—Ç–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏)
        
        // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ IP –Ω—É–∂–Ω–∞, —á—Ç–æ–±—ã –ø–µ—Ä–µ–º–µ—à–∞—Ç—å –±–∏—Ç—ã –±–ª–æ–∫–∞
        // –∏ –ø–æ–≤—ã—Å–∏—Ç—å –¥–∏—Ñ—Ñ—É–∑–∏—é –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –æ—Å–Ω–æ–≤–Ω—ã–º–∏ —Ä–∞—É–Ω–¥–∞–º–∏.
        // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ (IP) –¥–ª—è 32 –±–∏—Ç
        const IP = [
            16, 7, 20, 21, 29, 12, 28, 17,
            1, 15, 23, 26, 5, 18, 31, 10,
            2, 8, 24, 14, 32, 27, 3, 9,
            19, 13, 30, 6, 22, 11, 4, 25
        ];

        // –û–±—Ä–∞—Ç–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ IP^-1 –Ω—É–∂–Ω–∞ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ –±–∏—Ç
        // –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö —Ä–∞—É–Ω–¥–æ–≤ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.
        // –û–±—Ä–∞—Ç–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ (IP^-1)
        const IP_INV = [
            9, 17, 23, 31, 13, 28, 2, 18,
            24, 16, 30, 6, 26, 20, 10, 1,
            8, 14, 25, 3, 4, 29, 11, 19,
            32, 12, 22, 7, 5, 27, 15, 21
        ];

        // –¢–∞–±–ª–∏—Ü–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è E ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã –±–ª–æ–∫–∞,
        // —á—Ç–æ–±—ã —Å–º–µ—à–∏–≤–∞—Ç—å –µ—ë —Å —á–∞—Å—Ç—å—é –ø–æ–¥–∫–ª—é—á–∞ (—Å–æ–∑–¥–∞—ë—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç –∫–ª—é—á–∞).
        // –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è E –¥–ª—è 16 –±–∏—Ç -> 24 –±–∏—Ç–∞
        const E = [
            1, 2, 3, 4, 5, 6, 7, 8,
            5, 6, 7, 8, 9, 10, 11, 12,
            9, 10, 11, 12, 13, 14, 15, 16
        ];
        
        // S-boxes ‚Äî —è–¥—Ä–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ DES.
        // –û–Ω–∏ —Å–æ–∑–¥–∞—é—Ç –Ω–µ–ª–∏–Ω–µ–π–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ, —Ä–∞–∑—Ä—É—à–∞—é—â–µ–µ –ø—Ä—è–º—É—é –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å
        // –º–µ–∂–¥—É –≤—Ö–æ–¥–Ω—ã–º–∏ –∏ –≤—ã—Ö–æ–¥–Ω—ã–º–∏ –±–∏—Ç–∞–º–∏, –ø–æ–≤—ã—à–∞—è –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç—å.
        const S_BOXES = [
            [
                [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
                [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
                [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
                [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
            ],
            [
                [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
                [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
                [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
                [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
            ],
            [
                [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
                [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
                [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
                [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
            ],
            [
                [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
                [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
                [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
                [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
            ]
        ];

        // –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ P –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –≤—ã—Ö–æ–¥–æ–≤ S-box'–æ–≤
        // –º–µ–∂–¥—É —Ä–∞—É–Ω–¥–∞–º–∏ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –¥–∏—Ñ—Ñ—É–∑–∏—è).
        const P = [
            16, 7, 20, 21, 29, 12, 28, 17,
            1, 15, 23, 26, 5, 18, 31, 10
        ];

        // –¢–∞–±–ª–∏—Ü—ã PC1 –∏ PC2 –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–¥–∫–ª—é—á–µ–π –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞.
        // PC1 ‚Äî –≤—ã–±–∏—Ä–∞–µ—Ç –∏ –ø–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ—Ç –±–∏—Ç—ã –∏—Å—Ö–æ–¥–Ω–æ–≥–æ 64-–±–∏—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ (—É–¥–∞–ª—è–µ—Ç parity bits).
        // PC2 ‚Äî –≤—ã–±–∏—Ä–∞–µ—Ç –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –±–∏—Ç –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–∞.

        // PC1 –¥–ª—è –∫–ª—é—á–∞
        const PC1 = [
            57, 49, 41, 33, 25, 17, 9, 1,
            58, 50, 42, 34, 26, 18, 10, 2,
            59, 51, 43, 35, 27, 19, 11, 3,
            60, 52, 44, 36, 63, 55, 47, 39,
            31, 23, 15, 7, 62, 54, 46, 38,
            30, 22, 14, 6, 61, 53, 45, 37,
            29, 21, 13, 5, 28, 20, 12, 4
        ];

        // PC2 –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–π
        const PC2 = [
            14, 17, 11, 24, 1, 5, 3, 28,
            15, 6, 21, 10, 23, 19, 12, 4,
            26, 8, 16, 7, 27, 20, 13, 2,
            41, 52, 30, 47, 40, 51, 45, 43,
            49, 39, 38, 56, 34, 53, 46, 42,
            50, 36, 29, 32, 48, 44, 37, 33
        ];

        // –¢–∞–±–ª–∏—Ü–∞ SHIFTS –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω–∞—Å–∫–æ–ª—å–∫–æ —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏ —Å–¥–≤–∏–≥–∞—é—Ç—Å—è –ø–æ–ª–æ–≤–∏–Ω—ã –∫–ª—é—á–∞
        // –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ä–∞—É–Ω–¥–æ–º ‚Äî —ç—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–æ–¥–∫–ª—é—á–∏.
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–≤–∏–≥–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞
        const SHIFTS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

        // –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∏—Ç–∞–º–∏
        function stringToBits(str) {
            let bits = [];
            for (let i = 0; i < str.length; i++) {
                let byte = str.charCodeAt(i);
                for (let j = 7; j >= 0; j--) {
                    bits.push((byte >> j) & 1);
                }
            }
            return bits;
        }

        function bitsToString(bits) {
            let str = '';
            for (let i = 0; i < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8 && i + j < bits.length; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                str += String.fromCharCode(byte);
            }
            return str;
        }

        // –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ —Ç–∞–±–ª–∏—Ü–µ
        function permute(bits, table) {
            return table.map(i => bits[i - 1]);
        }

        function xor(bits1, bits2) {
            return bits1.map((bit, i) => bit ^ bits2[i]);
        }

        // –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–π —Å–¥–≤–∏–≥ –ø–æ–ª–æ–≤–∏–Ω—ã –∫–ª—é—á–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–¥–∫–ª—é—á–µ–π –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞.
        function leftShift(bits, shifts) {
            return bits.slice(shifts).concat(bits.slice(0, shifts));
        }

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–π
        function generateSubkeys(key) {
            let keyBits = stringToBits(key);
            while (keyBits.length < 64) keyBits.push(0);
            
            let permutedKey = permute(keyBits, PC1);
            let C = permutedKey.slice(0, 28);
            let D = permutedKey.slice(28, 56);
            
            let subkeys = [];
            for (let i = 0; i < 16; i++) {
                C = leftShift(C, SHIFTS[i]);
                D = leftShift(D, SHIFTS[i]);
                let combined = C.concat(D);
                subkeys.push(permute(combined, PC2));
            }
            
            return subkeys;
        }

        // –§—É–Ω–∫—Ü–∏—è –§–µ–π—Å—Ç–µ–ª—è ‚Äî —Ä–µ–∞–ª–∏–∑—É–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞:
        // —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ ‚Üí XOR —Å –ø–æ–¥–∫–ª—é—á–æ–º ‚Üí S-box ‚Üí –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ P.
        // –≠—Ç–æ —Å–æ–∑–¥–∞—ë—Ç –¥–∏—Ñ—Ñ—É–∑–∏—é –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ—Ç –∫–ª—é—á–∞.
        function feistel(right, subkey) {
            // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å 16 –¥–æ 24 –±–∏—Ç
            let expanded = permute(right, E);
            
            // XOR —Å –ø–æ–¥–∫–ª—é—á–æ–º
            let xored = xor(expanded, subkey.slice(0, 24));
            
            // S-boxes (4 –≥—Ä—É–ø–ø—ã –ø–æ 6 –±–∏—Ç -> 4 –±–∏—Ç–∞)
            let output = [];
            for (let i = 0; i < 4; i++) {
                let chunk = xored.slice(i * 6, (i + 1) * 6);
                let row = (chunk[0] << 1) | chunk[5];
                let col = (chunk[1] << 3) | (chunk[2] << 2) | (chunk[3] << 1) | chunk[4];
                let val = S_BOXES[i][row][col];
                
                for (let j = 3; j >= 0; j--) {
                    output.push((val >> j) & 1);
                }
            }
            
            // –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ P
            return permute(output, P);
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞:
        // - –ø—Ä–∏–º–µ–Ω—è–µ—Ç IP
        // - –¥–µ–ª–∏—Ç –±–ª–æ–∫ –Ω–∞ –ª–µ–≤—É—é/–ø—Ä–∞–≤—É—é –ø–æ–ª–æ–≤–∏–Ω—ã
        // - –ø—Ä–æ–≤–æ–¥–∏—Ç 16 —Ä–∞—É–Ω–¥–æ–≤ –§–µ–π—Å—Ç–µ–ª—è
        // - –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –ø–æ–ª–æ–≤–∏–Ω—ã –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç IP^-1.
        function encryptBlock(block, subkeys) {
            let bits = block;
            while (bits.length < 32) bits.push(0);
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞
            bits = permute(bits, IP);
            
            let left = bits.slice(0, 16);
            let right = bits.slice(16, 32);
            
            // 16 —Ä–∞—É–Ω–¥–æ–≤
            for (let i = 0; i < 16; i++) {
                let temp = right;
                let fResult = feistel(right, subkeys[i]);
                right = xor(left, fResult);
                left = temp;
            }
            
            // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∏ –æ–±—Ä–∞—Ç–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞
            let combined = right.concat(left);
            return permute(combined, IP_INV);
        }

        // –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞
        function decryptBlock(block, subkeys) {
            let reversedKeys = subkeys.slice().reverse();
            return encryptBlock(block, reversedKeys);
        }

        // –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function processText(text, key, isEncrypt) {
            if (!key || key.length !== 8) {
                alert('–ö–ª—é—á –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ä–æ–≤–Ω–æ 8 —Å–∏–º–≤–æ–ª–æ–≤!');
                return null;
            }

            let subkeys = generateSubkeys(key);
            let inputBits = stringToBits(text);
            
            // –î–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ –∫—Ä–∞—Ç–Ω–æ—Å—Ç–∏ 32
            while (inputBits.length % 32 !== 0) {
                inputBits.push(0);
            }
            
            let outputBits = [];
            
            for (let i = 0; i < inputBits.length; i += 32) {
                let block = inputBits.slice(i, i + 32);
                let processedBlock = isEncrypt ? 
                    encryptBlock(block, subkeys) : 
                    decryptBlock(block, subkeys);
                outputBits = outputBits.concat(processedBlock);
            }
            
            return bitsToString(outputBits);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞
        document.getElementById('fileInput').addEventListener('change', function(e) {
            let file = e.target.files[0];
            if (file) {
                document.getElementById('fileName').textContent = file.name;
                let reader = new FileReader();
                reader.onload = function(event) {
                    document.getElementById('textInput').value = event.target.result;
                };
                reader.readAsText(file);
            }
        });

        function encrypt() {
            let text = document.getElementById('textInput').value;
            let key = document.getElementById('keyInput').value;
            
            if (!text) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è!');
                return;
            }
            
            let result = processText(text, key, true);
            if (result) {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ base64 –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                let base64Result = btoa(result);
                document.getElementById('outputText').value = base64Result;
                document.getElementById('outputGroup').style.display = 'block';
            }
        }

        function decrypt() {
            let text = document.getElementById('textInput').value;
            let key = document.getElementById('keyInput').value;
            
            if (!text) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è!');
                return;
            }
            
            try {
                // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∏–∑ base64
                let decoded = atob(text);
                
                let result = processText(decoded, key, false);
                if (result) {
                    // –£–±–∏—Ä–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –±–∞–π—Ç—ã –≤ –∫–æ–Ω—Ü–µ
                    result = result.replace(/\0+$/, '');
                    document.getElementById('outputText').value = result;
                    document.getElementById('outputGroup').style.display = 'block';
                }
            } catch (e) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏! –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ç–µ–∫—Å—Ç –±—ã–ª –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω —ç—Ç–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π.');
            }
        }

        function downloadResult() {
            let text = document.getElementById('outputText').value;
            let blob = new Blob([text], { type: 'text/plain' });
            let a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'result.txt';
            a.click();
        }

        /* === –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–≤–µ—Ä—Ö DES === */
        function hashPassword() {
            let password = document.getElementById('password').value;
            let key = document.getElementById('keyInput').value;

            if (password.length !== 12) {
                alert("–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–æ–≤–Ω–æ 12 —Å–∏–º–≤–æ–ª–æ–≤!");
                return;
            }
            if (key.length !== 8) {
                alert("–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–æ–≤–Ω–æ 8 —Å–∏–º–≤–æ–ª–æ–≤!");
                return;
            }

            // –†–∞–∑–¥–µ–ª–∏—Ç—å –ø–∞—Ä–æ–ª—å –Ω–∞ 3 –±–ª–æ–∫–∞ –ø–æ 4 —Å–∏–º–≤–æ–ª–∞
            let blocks = [
                password.slice(0, 4),
                password.slice(4, 8),
                password.slice(8, 12)
            ];

            let hashCombined = "";
            let prevBlock = "\0\0\0\0";

            for (let block of blocks) {
                // XOR —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –±–ª–æ–∫–æ–º
                let xorBlock = "";
                for (let i = 0; i < 4; i++) {
                    xorBlock += String.fromCharCode(block.charCodeAt(i) ^ prevBlock.charCodeAt(i));
                }

                // –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –±–ª–æ–∫ —á–µ—Ä–µ–∑ DES
                let encrypted = processText(xorBlock, key, true);
                prevBlock = encrypted.slice(0, 4); // –æ–±–Ω–æ–≤–ª—è–µ–º "—Ü–µ–ø–æ—á–∫—É"
                hashCombined += encrypted;
            }

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ base64 –¥–ª—è –≤—ã–≤–æ–¥–∞
            let hashBase64 = btoa(hashCombined);
            document.getElementById('output').innerHTML =
                `<b>–•–µ—à –ø–∞—Ä–æ–ª—è:</b><br>${hashBase64}`;
        }
    </script>
</body>
</html>