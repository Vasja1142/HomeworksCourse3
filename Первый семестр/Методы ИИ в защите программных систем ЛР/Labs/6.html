<!-- task6_compression.html -->
<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Двухступенчатое сжатие (LZW + Arithmetic)</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 900px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        textarea,
        input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            margin-bottom: 15px;
            resize: vertical;
        }

        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            text-transform: uppercase;
        }

        .btn-compress {
            background: #ff7e5f;
            color: white;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
        }

        .btn-decompress {
            background: #43cea2;
            color: white;
            background: linear-gradient(to right, #43cea2, #185a9d);
        }

        button:hover {
            transform: scale(1.02);
            opacity: 0.9;
        }

        .output-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-wrap: break-word;
            margin-bottom: 10px;
            border-left: 4px solid rgba(255, 255, 255, 0.5);
        }

        .step-label {
            color: #ddd;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Two-Stage Compression</h1>

        <div class="panel">
            <label>1. Ввод текста</label>
            <textarea id="inputText" rows="3" placeholder="Введите текст для сжатия..."></textarea>
            <button class="btn-compress" onclick="runCompression()">Сжать (LZW -> Arithmetic)</button>

            <div id="compressionResults" style="display:none; margin-top: 20px;">
                <div class="step-label">Ступень 1: Коды LZW</div>
                <div class="output-box" id="lzwResult"></div>

                <div class="step-label">Ступень 2: Арифметическое число (Результат)</div>
                <div class="output-box" id="arithmeticResult"></div>

                <div class="step-label">Модель частот (Необходима для расшифровки)</div>
                <div class="output-box" id="modelResult"></div>
            </div>
        </div>

        <div class="panel">
            <label>2. Расшифровка</label>
            <input type="text" id="encodedInput" placeholder="Вставьте число (Arithmetic result)">
            <textarea id="modelInput" rows="2" placeholder="Вставьте JSON модели частот"></textarea>
            <button class="btn-decompress" onclick="runDecompression()">Расшифровать</button>

            <div id="decompressionResults" style="display:none; margin-top: 20px;">
                <div class="step-label">Восстановленный текст:</div>
                <div class="output-box" id="finalResult"></div>
            </div>
        </div>
    </div>

    <script>
    // Настройка точности: 50 знаков (можно ставить хоть 100n, но будет медленнее)
    const PRECISION_POWER = 50n; 
    const SCALE = 10n ** PRECISION_POWER;

    // --- LZW (без изменений) ---
    function lzwEncode(s) {
        if (!s) return [];
        const dict = {};
        for (let i = 0; i < 256; i++) dict[String.fromCharCode(i)] = i;
        let p = "", code = 256, out = [];
        for (let i = 0; i < s.length; i++) {
            let c = s.charAt(i), pc = p + c;
            if (dict.hasOwnProperty(pc)) {
                p = pc;
            } else {
                out.push(dict[p]);
                dict[pc] = code++;
                p = c;
            }
        }
        if (p !== "") out.push(dict[p]);
        return out;
    }

    function lzwDecode(codes) {
        if (!codes || codes.length === 0) return "";
        const dict = {};
        for (let i = 0; i < 256; i++) dict[i] = String.fromCharCode(i);
        let p = codes[0], code = 256;
        let out = dict[p], phrase = dict[p];
        for (let i = 1; i < codes.length; i++) {
            let c = codes[i];
            let entry;
            if (dict[c]) {
                entry = dict[c];
            } else {
                if (c === code) {
                    entry = phrase + phrase[0];
                } else {
                    return "Ошибка LZW";
                }
            }
            out += entry;
            dict[code++] = phrase + entry[0];
            phrase = entry;
        }
        return out;
    }

    // --- ARITHMETIC CODING (BigInt Версия) ---
    
    function arithmeticEncode(input) {
        // 1. Модель частот
        const freqs = {};
        input.forEach(s => freqs[s] = (freqs[s] || 0) + 1);
        const total = BigInt(input.length);
        
        // Сортируем символы
        const symbols = Object.keys(freqs).map(Number).sort((a,b) => a-b);
        
        // Строим кумулятивные счетчики (в целых числах)
        const ranges = {};
        let cum = 0n;
        symbols.forEach(s => {
            let count = BigInt(freqs[s]);
            ranges[s] = { l: cum, h: cum + count };
            cum += count;
        });

        // 2. Кодирование
        // Работаем в интервале [0, SCALE], где SCALE = 10^50
        let low = 0n;
        let high = SCALE;

        for (let i = 0; i < input.length; i++) {
            let s = input[i];
            let range = high - low;
            
            // Формула: low = low + range * start / total
            // Используем BigInt умножение перед делением для сохранения точности
            let newHigh = low + (range * ranges[s].h) / total;
            let newLow = low + (range * ranges[s].l) / total;
            
            low = newLow;
            high = newHigh;
        }

        // Результат берем как (low + high) / 2
        // Но для вывода нам нужно представить это как "0.xxxx..."
        let resultBigInt = (low + high) / 2n;
        
        // Форматируем строку: добавляем ведущие нули, если число меньше SCALE
        let resStr = resultBigInt.toString();
        while (resStr.length < Number(PRECISION_POWER)) {
            resStr = "0" + resStr;
        }
        
        return { 
            valStr: "0." + resStr, // Строковое представление длинного числа
            model: { freqs, total: input.length } 
        };
    }

    function arithmeticDecode(valStr, model) {
        // Парсим модель
        const { freqs, total: totalNum } = model;
        const total = BigInt(totalNum);
        
        // Восстанавливаем BigInt значение из строки "0.12345..."
        let decimalPart = valStr.split('.')[1];
        if (!decimalPart) throw new Error("Неверный формат числа");
        
        // Если точность при вводе меньше ожидаемой, дополняем нулями
        if (decimalPart.length < Number(PRECISION_POWER)) {
            decimalPart = decimalPart.padEnd(Number(PRECISION_POWER), '0');
        } 
        // Если больше - обрезаем (или оставляем, BigInt стерпит)
        else if (decimalPart.length > Number(PRECISION_POWER)) {
             decimalPart = decimalPart.slice(0, Number(PRECISION_POWER));
        }

        const val = BigInt(decimalPart);
        
        // Строим диапазоны
        const symbols = Object.keys(freqs).map(Number).sort((a,b) => a-b);
        const ranges = {};
        let cum = 0n;
        symbols.forEach(s => {
            let count = BigInt(freqs[s]);
            ranges[s] = { l: cum, h: cum + count };
            cum += count;
        });

        // Декодирование
        let output = [];
        let low = 0n;
        let high = SCALE;
        
        for(let i=0; i<totalNum; i++) {
            let range = high - low;
            
            // Нам нужно найти символ S, для которого:
            // low + range*ranges[S].l/total <= val < low + range*ranges[S].h/total
            // Преобразуем неравенство, чтобы избавиться от деления:
            // (val - low) * total / range
            
            // "Target" - это проекция значения val на диапазон [0, total)
            let target = ((val - low) * total) / range;
            
            let found = false;
            for(let s of symbols) {
                if(target >= ranges[s].l && target < ranges[s].h) {
                    output.push(s);
                    
                    let newHigh = low + (range * ranges[s].h) / total;
                    let newLow = low + (range * ranges[s].l) / total;
                    
                    low = newLow;
                    high = newHigh;
                    found = true;
                    break;
                }
            }
            if (!found) break; 
        }
        return output;
    }

    // --- UI Handlers ---
    function runCompression() {
        const text = document.getElementById('inputText').value;
        if(!text) return alert("Введите текст!");

        try {
            // 1. LZW
            const lzwCodes = lzwEncode(text);
            document.getElementById('lzwResult').textContent = lzwCodes.join(', ');

            // 2. Arithmetic (BigInt)
            const arith = arithmeticEncode(lzwCodes);
            
            document.getElementById('arithmeticResult').textContent = arith.valStr;
            document.getElementById('modelResult').textContent = JSON.stringify(arith.model);
            
            document.getElementById('compressionResults').style.display = 'block';
        } catch (e) {
            alert("Ошибка: " + e.message);
            console.error(e);
        }
    }

    function runDecompression() {
        try {
            const valStr = document.getElementById('encodedInput').value;
            const modelStr = document.getElementById('modelInput').value;
            
            if (!valStr || !modelStr) return alert("Заполните поля!");

            const model = JSON.parse(modelStr);

            // 1. Arithmetic Decode
            const lzwCodes = arithmeticDecode(valStr, model);
            
            // 2. LZW Decode
            const text = lzwDecode(lzwCodes);
            
            document.getElementById('finalResult').textContent = text;
            document.getElementById('decompressionResults').style.display = 'block';
        } catch(e) {
            alert("Ошибка декодирования: " + e.message);
            console.error(e);
        }
    }
</script>
</body>

</html>